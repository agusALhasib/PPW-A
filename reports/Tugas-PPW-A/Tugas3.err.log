Traceback (most recent call last):
  File "/usr/local/lib/python3.10/dist-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/local/lib/python3.10/dist-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
  File "/usr/lib/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Teks baru yang ingin diprediksi
new_text_1 = [''' Jakarta - Rider Ducati, Enea Bastianini, memetik kemenangan di MotoGP Emilia Romagna 2024. Dia menyebut pencapaian itu luar biasa.
Di Sirkuit Misano, Minggu (22/9/2024), Bastianini menjadi yang tercepat dalam 27 balapan. Dia menyalip rider Pramac Ducati Jorge Martin pada lap terakhir dengan catatan waktu 41 menit 14,653 detik.
Momen Bastianini menyalip Martin terjadi pada tikungan empat. Martin beberapa kalai goyang saat mengendarai motor, Bastianini mengambil sisi dalam tikungan untuk bisa merebut posisi terdepan."Ini adalah balapan yang luar biasa. Jorge melaju dengan sempurna dan terlalu sulit untuk mencoba melewatinya," kata Bastianini di Marca.
"Pada lap terakhir, saya melihat sedikit ruang di tikungan 4 dan saya sedikit melewati batas, tapi pada akhirnya saya bisa menutup jalur."
"Luar biasa bisa mendapat kemenangan hari ini dan kembali ke podium teratas," kata dia menambahkan.
Dengan kemenangan Bastianini, Ducati mencatatkan sejarah. Tim pabrikan asal Italia itu meraih kemenangan ke-100. Lebih istimewanya lagi, hasil itu didapat saat balapan kandang.
Sementara bagi Bastianini, ini merupakan kemenangan kedua di MotoGP 2024. Sebelumnya, dia juga berhasil menjadi pemenang di MotoGP Inggris.
''']

new_text_2 = [''' Jakarta - Banyak kuliner viral yang populer beberapa bulan saja.Namun, ada juga kuliner viral yang bertahan hingga sekarang. Tersebar di Jakarta dan Bandung.
Kuliner viral bermunculan di media sosial, kebanyakan berasal dari Jakarta dan Bandung. Beberapa kuliner viral ini ramai diburu para pelanggannya, tetapi banyak juga yang populernya hanya sesaat saja.
Beberapa kuliner viral di Jakarta dan Bandung berikut ini masih ramai dan populer. Di antaranya gultik, kuotie, hingga sate jando.
Berikut 5 kuliner viral yang sampai sekarang masih ramai:
1. Gultik
Foodies Jakarta pasti sudah tak asing lagi dengan makanan satu ini, namanya gultik atau gulai tikungan. Gultik banyak ditawarkan oleh penjual kaki lima di kawasan Blok M, Jakarta Selatan. Tepatnya berada di dekat Plaza Blok M dan Bulungan.
Tempat makan gultik di Blok M ada sangat banyak, kamu bisa memilih salah satu di antaranya karena rasa yang ditawarkan tak jauh berbeda. Seporsi gultik dibanderol mulai dari Rp 15.000, untuk satenya sekitar Rp 5.000 saja.
2. Kuotie Jalan Nanas
Kuotie Mas Iman atau yang kini disebut Kuotie Jalan Nanas ini sangat viral. Lokasinya ada di Jalan Nanas, Bandung, tepat berjualan di depan kafe Little Contrast.
Penjualnya hanya menggunakan gerobak sederhana, tapi kuotie ini laris-manis diantre pelanggan. Dalam sehari, kuotie ini bisa habis sekitar 1.000 buah. Untuk isinya halal, menggunakan daging ayam, kucai, dan telur.
Kuotie ini ditawarkan dengan harga Rp 5.000 per buahnya. Biasanya orang minimal akan memesan 10 buah dengan harga Rp 50.000. Selain makan di tempat, kuotie ini juga bisa dijadikan oleh-oleh lho! ''']

# Gabungkan kedua teks menjadi satu list
new_text = new_text_1 + new_text_2

# Preprocessing dan transformasi menggunakan TF-IDF yang sudah disimpan
new_text_tfidf = tfidf.transform(new_text)

# Melakukan prediksi menggunakan model Logistic Regression
predictions = model.predict(new_text_tfidf)

# Hasil prediksi
predicted_categories = ["Makanan" if prediction == 'Makanan' else "Olahraga" for prediction in predictions]

# Output hasil prediksi untuk masing-masing teks
for i, category in enumerate(predicted_categories):
    print(f"Prediksi untuk teks {i+1}: {category}")


------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mValueError[0m                                Traceback (most recent call last)
[0;32m<ipython-input-12-229be3134fdb>[0m in [0;36m<cell line: 30>[0;34m()[0m
[1;32m     28[0m [0;34m[0m[0m
[1;32m     29[0m [0;31m# Melakukan prediksi menggunakan model Logistic Regression[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 30[0;31m [0mpredictions[0m [0;34m=[0m [0mmodel[0m[0;34m.[0m[0mpredict[0m[0;34m([0m[0mnew_text_tfidf[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     31[0m [0;34m[0m[0m
[1;32m     32[0m [0;31m# Hasil prediksi[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/lib/python3.10/dist-packages/sklearn/linear_model/_base.py[0m in [0;36mpredict[0;34m(self, X)[0m
[1;32m    380[0m         """
[1;32m    381[0m         [0mxp[0m[0;34m,[0m [0m_[0m [0;34m=[0m [0mget_namespace[0m[0;34m([0m[0mX[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 382[0;31m         [0mscores[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0mdecision_function[0m[0;34m([0m[0mX[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    383[0m         [0;32mif[0m [0mlen[0m[0;34m([0m[0mscores[0m[0;34m.[0m[0mshape[0m[0;34m)[0m [0;34m==[0m [0;36m1[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[1;32m    384[0m             [0mindices[0m [0;34m=[0m [0mxp[0m[0;34m.[0m[0mastype[0m[0;34m([0m[0mscores[0m [0;34m>[0m [0;36m0[0m[0;34m,[0m [0mindexing_dtype[0m[0;34m([0m[0mxp[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/lib/python3.10/dist-packages/sklearn/linear_model/_base.py[0m in [0;36mdecision_function[0;34m(self, X)[0m
[1;32m    361[0m         [0mxp[0m[0;34m,[0m [0m_[0m [0;34m=[0m [0mget_namespace[0m[0;34m([0m[0mX[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    362[0m [0;34m[0m[0m
[0;32m--> 363[0;31m         [0mX[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0m_validate_data[0m[0;34m([0m[0mX[0m[0;34m,[0m [0maccept_sparse[0m[0;34m=[0m[0;34m"csr"[0m[0;34m,[0m [0mreset[0m[0;34m=[0m[0;32mFalse[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    364[0m         [0mscores[0m [0;34m=[0m [0msafe_sparse_dot[0m[0;34m([0m[0mX[0m[0;34m,[0m [0mself[0m[0;34m.[0m[0mcoef_[0m[0;34m.[0m[0mT[0m[0;34m,[0m [0mdense_output[0m[0;34m=[0m[0;32mTrue[0m[0;34m)[0m [0;34m+[0m [0mself[0m[0;34m.[0m[0mintercept_[0m[0;34m[0m[0;34m[0m[0m
[1;32m    365[0m         [0;32mreturn[0m [0mxp[0m[0;34m.[0m[0mreshape[0m[0;34m([0m[0mscores[0m[0;34m,[0m [0;34m([0m[0;34m-[0m[0;36m1[0m[0;34m,[0m[0;34m)[0m[0;34m)[0m [0;32mif[0m [0mscores[0m[0;34m.[0m[0mshape[0m[0;34m[[0m[0;36m1[0m[0;34m][0m [0;34m==[0m [0;36m1[0m [0;32melse[0m [0mscores[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/lib/python3.10/dist-packages/sklearn/base.py[0m in [0;36m_validate_data[0;34m(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)[0m
[1;32m    652[0m [0;34m[0m[0m
[1;32m    653[0m         [0;32mif[0m [0;32mnot[0m [0mno_val_X[0m [0;32mand[0m [0mcheck_params[0m[0;34m.[0m[0mget[0m[0;34m([0m[0;34m"ensure_2d"[0m[0;34m,[0m [0;32mTrue[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 654[0;31m             [0mself[0m[0;34m.[0m[0m_check_n_features[0m[0;34m([0m[0mX[0m[0;34m,[0m [0mreset[0m[0;34m=[0m[0mreset[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    655[0m [0;34m[0m[0m
[1;32m    656[0m         [0;32mreturn[0m [0mout[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/lib/python3.10/dist-packages/sklearn/base.py[0m in [0;36m_check_n_features[0;34m(self, X, reset)[0m
[1;32m    441[0m [0;34m[0m[0m
[1;32m    442[0m         [0;32mif[0m [0mn_features[0m [0;34m!=[0m [0mself[0m[0;34m.[0m[0mn_features_in_[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 443[0;31m             raise ValueError(
[0m[1;32m    444[0m                 [0;34mf"X has {n_features} features, but {self.__class__.__name__} "[0m[0;34m[0m[0;34m[0m[0m
[1;32m    445[0m                 [0;34mf"is expecting {self.n_features_in_} features as input."[0m[0;34m[0m[0;34m[0m[0m

[0;31mValueError[0m: X has 5242 features, but LogisticRegression is expecting 5000 features as input.

